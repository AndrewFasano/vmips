\input texinfo      @c -*- texinfo -*-
@c %**start of header
@setfilename vmips.info
@settitle VMIPS Programmer's Manual
@c %**end of header
@syncodeindex fn cp
@syncodeindex pg cp

@ifinfo
@format
START-INFO-DIR-ENTRY
* VMIPS: (vmips).                A MIPS R3000 simulator.
END-INFO-DIR-ENTRY
@end format
@end ifinfo

@ifinfo
This is the VMIPS Programmer's Manual, First Edition, for version 1.0.

Copyright @copyright{} 2001 Brian R. Gaeke.
@end ifinfo

@titlepage
@center @titlefont{VMIPS Programmer's Manual}
@page
@vskip 0pt plus 1filll

@vskip 0pt plus 1filll
Copyright @copyright{} 2001 Brian R. Gaeke.
Permission is granted to copy, distribute and/or modify this
document under the terms of the GNU Free Documentation License,
Version 1.1 or any later version published by the Free Software
Foundation; with no Invariant Sections, no Front-Cover Texts and
no Back-Cover Texts.  A copy of the license is included in the
section entitled "GNU Free Documentation License".
@end titlepage

@ifnottex
@node Top, Overview, , (dir)
@top
This is the VMIPS Programmer's Manual, First Edition, for version 1.0.

Copyright @copyright{} 2001 Brian R. Gaeke.

@menu
* Overview::              The rationale for VMIPS.
* Getting Started::       4 simple steps to building VMIPS programs.
* An Example::            Hello, World on VMIPS.

* Building Programs::     What you need to know when compiling for VMIPS.
* Invoking vmips::        Starting and stopping the simulation.
* Customizing::           The @file{.vmipsrc} file.
* Invoking vmipstool::    A handy front-end to MIPS compiler tools.
* Programming::           Tips on writing assembly language programs.
* Debugging::             VMIPS supports debugging with GDB.
* Devices::               Virtual hardware supported by VMIPS.
* Extending::             Writing new functionality for VMIPS.

* Installation::          Getting VMIPS ready to boot on your machine.
* Reporting Bugs::        What to do when vmips dumps core, or worse.
* Future Directions::     VMIPS is looking for a few good hackers.
* References::            Good books about MIPS.

* Copying::               VMIPS is free software, and its documentation
                          is free documentation.

* Index::
@end menu
@end ifnottex

@comment node-name, next,          previous, up
@node Overview, Getting Started, Top, Top
@chapter Overview

@cindex simulator
@cindex virtual machine
@cindex MIPS
@cindex MIPS R3000
VMIPS is a simulator for a machine compatible with the MIPS R3000 RISC
architecture. VMIPS consists entirely of software; no special hardware is
required to run programs on VMIPS---that is, VMIPS is a virtual machine.

@cindex RISC
@cindex RISC architecture
@cindex architecture
Since VMIPS is based on an already-existing architecture, it is relatively
easy to find tools to build programs that will run on VMIPS. Since VMIPS is
based on a RISC architecture, its primitive machine-language commands are
all fairly simple to understand.

VMIPS is easily extended by programmers to include more virtual devices,
such as frame buffers, disk drives, etc. VMIPS is written in C++ and uses
a fairly simple class structure. Furthermore, VMIPS is intended to be a
"concrete" virtual machine which its users can modify at will---"concrete"
meaning that it maintains a tight correspondence between its structures
and structures which actually appear in modern physical computer hardware.
For example, a programmer who wished to modify the CPU simulation could
easily extract the @code{CPU} class from the VMIPS source code, and replace
it with one which was more to his/her liking.

@cindex debugger
@pindex gdb
VMIPS is also designed with debugging and testing in mind, offering an
interface to the GNU debugger GDB by which programs can be debugged while
they run on the simulator. As such, it is intended to be a practical
simulator target for compilers and assembly language/hardware-software
interface courses.

@cindex free software
VMIPS is free software. This means that you are free to share VMIPS
with everyone, and we encourage you to do so, but we do not give you
the freedom to restrict others from sharing it with everyone. For a
comprehensive explanation please read the GNU General Public License.

@node Getting Started, An Example, Overview, Top
@chapter Getting Started

Step 0. If VMIPS is installed on your system, you can start building
programs with it right away.  Otherwise, you (or your system
administrator) will have to compile VMIPS first; see the appendix on
Installation.

@cindex vmipstool usage
@pindex vmipstool
@pindex vmips
Step 1. First, compile your program. You should have a MIPS cross-compiler
available.  VMIPS supports the GNU C Compiler; most installations of
VMIPS will also have an installation of the GNU C Compiler targetting
the MIPS architecture.  Your easiest interface to the C compiler will
probably be through the @samp{vmipstool} program; to run the MIPS compiler
that VMIPS was installed with, use the @samp{vmipstool --compile} command.

@cindex linking, using vmipstool
Step 2. Link your program with any support code necessary. VMIPS comes
with some canned support code, in the share/setup directory, or you
can write your own support code. VMIPS comes with a linker script for
simple standalone programs, which you can run with @samp{vmipstool --link},
or you can write your own linker script.

@cindex ROM, building with vmipstool
Step 3. Build a ROM image. This is necessary because the current version of
VMIPS does not read in executables. Most real machines don't; they have
an embedded program on a piece of flash ROM that reads in the first
executable and runs it. This makes development a little more realistic, but
not quite so convenient; this may change in the future, but for now it's
necessary. To build a ROM image, use the script that comes with VMIPS, by
running @samp{vmipstool --make-rom}.

Step 4. Start the simulator using @samp{vmips ROMFILE}, where @samp{ROMFILE} is
the name of your ROM image.  Your program should run to completion,
and if you are using the canned setup code that comes with VMIPS, 
the simulator should halt when it hits the first @code{break} instruction, which
should happen right after your @code{entry} function returns.

@node An Example, Building Programs, Getting Started, Top
@chapter An Example

@pindex vmipstool 
@pindex vmips
Let's assume you have VMIPS already compiled, and that you have some
setup code in @file{setup.s}, and a standalone program (i.e., not one
meant to run under an operating system) in @file{hello.c}.

@cindex assembling, using vmipstool
First assemble the setup code.
@example
vmipstool --assemble -o setup.o setup.s
@end example

@cindex compiling, using vmipstool
Compile your program:
@example
vmipstool --compile -c hello.c
@end example

@cindex linking, using vmipstool
Then, link your program and the setup code together to produce an executable:
@example
vmipstool --link -o hello setup.o hello.o
@end example

@cindex ROM, building with vmipstool
Build a ROM image from the executable:
@example
vmipstool --make-rom hello hello.rom
@end example

Run the program.
@example
vmips hello.rom
@end example

@cindex halting simulation
The program will terminate, by default, when your setup code generates
a breakpoint exception (using the @code{break} instruction, for
example). This termination condition can be changed by adding one of the
@option{halt} options to the file @file{.vmipsrc} in your home directory.

@node Building Programs, Invoking vmips, An Example, Top
@chapter Building Programs

@section Source Languages

@cindex C language
Programs for VMIPS are generally built out of C or assembly-language source
code. It is theoretically possible to use C++ or other languages, but the
infrastructure required has not yet been investigated or documented.

@section ROM Programs

@cindex ROM, programs in
The easiest way to get VMIPS to run a program is to install that program as
the VMIPS ROM. Building a C program as a ROM requires that you link it with
some setup code.

@section Default Setup Code

@cindex setup code
@cindex startup code
@cindex initialization code
This section describes the default VMIPS setup code.  It also describes
the minimal set of things you need to do before you can run C code
from the ROM, since that is the intended purpose of the default VMIPS
setup code.

Start by clearing out registers and TLB entries.

@cindex stack pointer, initializing
Set yourself up a stack pointer ($sp). Usually this can just be some
number of megabytes above the end of your code's data segment.  You can
get the address of the end of your code's data segment from your linker
script.

@cindex globals pointer, initializing
Set up your globals pointer ($gp), if your code uses global data.
You can get the right address from your linker script.

@cindex ROM, data in
If you have writable data in ROM, your C code probably doesn't realize
that it's in ROM, and it will want to write to it. You should copy the
writable data to RAM. There is code to do this in the canned setup code
provided with VMIPS.

@findex main
@findex entry
Finally, your setup code should finish by calling the entry point of your
C code. Usually this will have a name like @code{entry}; using the name
@code{main} is not recommended, because many versions of GCC assume that
they can call standard C runtime setup functions (such as are normally
found in @file{crt0.o}) from the beginning of @code{main}. You may or
may not want this.

@cindex break instruction, to halt machine
When the C code returns, you will probably want to halt the machine;
the default way to do this is by executing a break instruction. Read the
following section for details.

@section Exceptions

@subsection Handling exceptions

@cindex exceptions, handling
Your startup code should have some kind of exception support.  If you
don't, exceptions are likely to make your program loop forever, because
the jump to the exception vector will result in the execution of garbage
or in a unmapped access, either of which are likely to cause exceptions.

@cindex exceptions, minimal handler for
@cindex break instruction, to halt machine
An absolutely minimal exception handler is a break instruction at address
0xbfc00180, which will halt the machine on any exception, providing
you have the @option{haltbreak} option set. This is also a handy way to halt
the machine after your program ends, if you are writing kernel code;
just follow the jump to your kernel code by a @code{break} instruction.

@subsection Exception vectors

@cindex exceptions, vectors for
@cindex exceptions, addresses for
If the Boot-time Exception Vectors are in use, exceptions use the
base address 0xbfc00100 (which is in unmapped, uncached kernel space),
otherwise they use the base address 0x80000000 (which is in unmapped,
cached kernel space).  You can control this by setting or clearing the
Boot-time Exception Vector bit (bit 22, or 0x00400000) in the Status
register (register 12 of coprocessor zero). If the bit is set, the
Boot-time Exception Vectors will be used.

@cindex exceptions, user-space TLB miss
User-space TLB Miss exceptions have a special vector, which is obtained by
adding 0 to the base address. All other exceptions use the general vector,
which is obtained by adding 0x080 to the base address. This obviously
places a bit of a restriction on the layout of the beginning of your ROM code:
the setup code must either fit in the first 0x100 bytes, or it must be structured
so that it jumps past the exception vectors.

@subsection Exception codes and their meanings

@cindex exceptions, codes for
Whenever control is transferred to your exception handler, the ExcCode
field of the Cause register, that is, bits 6 - 2 (0x007c) of register 13
of coprocessor 0, are filled in with one of the following exception codes.
Each exception code has a canonical short name, included in parentheses next
to the exception code number, and is followed by a short description of the
circumstances where it occurs.

@table @code
@item 0 (Int)
Hardware or software interrupt. Some device or process is trying to get
the processor's attention.

@item 1 (Mod)
TLB modification exception. The memory address translation mapped to a TLB
entry, but that entry's "dirty" bit was set.

@item 2 (TLBL)
TLB exception caused by a data load (i.e., a load word or similar
instruction) or instruction fetch. The memory address translation did
not match any valid TLB entry.

@item 3 (TLBS)
TLB exception caused by a data store (i.e., a store word or similar
instruction). The memory address translation did not match any valid TLB
entry.

@item 4 (AdEL)
Address error exception caused by a data load or instruction fetch. The
PC was not word-aligned, or the address the load instruction wanted to
load from was not aligned to the width of the load instruction. (For
example, load halfword instructions must be 2-byte aligned.)

@item 5 (AdES)
Address error exception caused by a data store. The address the store
instruction wanted to store to was not aligned to the width of the store
instruction. (For example, store halfword instructions must be 2-byte
aligned.)

@item 6 (IBE)
Bus error caused by an instruction fetch. The PC does not correspond to
any real area of memory.

@item 7 (DBE)
Bus error caused by a data load or store. The target address of the load
or store instruction does not correspond to any real area of memory.

@item 8 (Sys)
SYSCALL exception. Some code was trying to call the operating system,
using a SYSCALL instruction.  This exception is the processor's way of
transferring control to the operating system.

@item 9 (Bp)
Breakpoint exception. Some process executed a BREAK instruction. This is the
processor's way of allowing the operating system to stop the process and do
whatever is appropriate (alert the user using the debugger, for example).

@item 10 (RI)
Reserved instruction exception. Some code executed something which wasn't
a valid MIPS-1 instruction.

@item 11 (CpU)
Coprocessor Unusable. Some code executed an instruction which tried to
reference a coprocessor that isn't configured in VMIPS.

@item 12 (Ov)
Arithmetic Overflow.  Some code executed an instruction whose arithmetic
answer was too big to fit in a register using two's-complement arithmetic. The
processor issues this exception so that the operating system can stop or
otherwise signal the process.

@item 13 (Tr)
Trap. This exception is only issued on the R4000 or R6000 processor and
compatibles.

@item 14 (NCD)
LDCz or SDCz (coprocessor load/store) using an address which wasn't in
the cache. This exception is only issued on the R6000 processor and compatibles.

@item 14 (VCEI)
Virtual Coherency Exception (instruction). This exception is only issued on
the R4000 processor and compatibles.

@item 15 (MV)
Machine check exception. This exception is only issued on
the R6000 processor and compatibles.

@item 15 (FPE)
Floating-point exception. This exception is only issued on
the R4000 processor and compatibles.

@item 16-22
Reserved, not used.

@item 23 (WATCH)
Reference to WatchHi/WatchLo address detected. This exception is only issued
on the R4000 processor and compatibles.

@item 24-30
Reserved, not used.

@item 31 (VCED)
Virtual Coherency Exception (data). This exception is only issued on
the R4000 processor and compatibles.
@end table

@subsection Exception prioritizing

It is possible for more than one exception to occur during the emulation
of the same instruction.  The MIPS architecture has a system for
determining which of a set of conflicting exceptions is reported to
the exception handler.
 
When two or more exceptions occur on the same execution of the same
instruction, only one is reported, according to the priority
list, below. The ordering is by exception code (EXCCODE) and mode of memory
access (MODE), where applicable. Each ordered pair (EXCCODE, MODE)
below has the priority listed in brackets. * denotes a position where
any value matches.

This prioritization is implemented in the @code{exception_priority()}
member function of class CPU.

@table @code
@item [1]
Address error - instruction fetch 
(AdEL, INSTFETCH)

@item [2]
TLB refill - instruction fetch
TLB invalid - instruction fetch 
(TLBL, INSTFETCH)
(TLBS, INSTFETCH)

@item [3]
Bus error - instruction fetch
(IBE, *)

@item [4]
Integer overflow, Trap, System call, Breakpoint, Reserved
Instruction, or Coprocessor Unusable
(Ov, *)
(Tr, *)
(Sys, *)
(Bp, *)
(RI, *)
(CpU, *)

@item [5]
Address error - data load or data store
(AdEL, DATALOAD)
(AdES, *)

@item [6]
TLB refill - data load or data store
TLB invalid - data load or data store
(TLBL, DATALOAD)
(TLBS, DATALOAD)
(TLBL, DATASTORE)
(TLBS, DATASTORE)

@item [7]
TLB modified - data store
(Mod, *)

@item [8]
Bus error - data load or data store
(DBE, *)

@item [9]
Interrupt
(Int, *)
@end table

@section Linking

You want the text section of your program to start with the setup
code, so link in the setup code first --- that is, put the name of the
object file containing the setup code first on the linker command line.

You want the setup code to start at 0xbfc00000, which is the MIPS
reset exception vector. In practical terms, when VMIPS starts up,
it will reset. When VMIPS resets, it jumps to 0xbfc00000, which is
the beginning of your setup code. 

@section Common Errors in Compilation

If the linker complains about not being able to find the
symbol @code{_gp_disp}, you should turn on the GCC option
@option{-mno-abicalls}. @code{_gp_disp} is used by the SGI N32 ABI for
MIPS ELF.  One reliable reference source claims, ``@code{_gp_disp} is
a reserved symbol defined by the linker to be the distance between the
lui instruction and the context pointer.'' The GNU linkers currently in
use do not appear to support this function.

If you get lots of @code{R_MIPS_GPREL16} relocation failures from
the linker, there are two workarounds: either combine all the files
together first with @samp{ld -x -r -o bigfile.o @var{<all your files>}}
and then use @samp{vmipstool --link} on @file{bigfile.o}, or compile
with @option{-G 0} in your @code{CFLAGS}.

@subsection Dealing with kernel code in GCC

If you have a @code{main()} function in your code, GCC expects it to
return an int.  If you don't like this, use @option{-ffreestanding}
or @option{-Wno-main}. You have to have GCC 2.95.2 for this to work,
though; it won't work in EGCS 1.1.1.

If you have a @code{main()} function in your code, GCC will try to
call @code{__main} or some other kind of setup function even if you
use @option{-ffreestanding}.  There is probably a way to configure the cross
compiler so that it won't try to do this;  it will be documented here
once it is discovered.  A simple workaround is to call the entry function
@code{entry} instead of @code{main}.

@subsection Building ROMs

If it takes a long time to build a ROM or the ROM file fills the disk,
make sure all the sections your linker is producing are accounted for
in the linker script. Do an @samp{objdump -x} on the executable which
you are using to build the ROM image, and make sure that the difference
between any two of the LMAs (load memory addresses) of the sections
in the file is not a lot bigger than the total size of the executable.
This metric is strictly a rule of thumb, but it easily identifies when
a section has not been put into the linker script: if a load memory
address for some section is expecting to be in RAM (0xa0000000, for
example), and the load memory address for all the other sections is in
ROM (around 0xbfc00000), then you will lose because writing out a memory
image to be used as a ROM file would take roughly 0xbfc00000 - 0xa0000000
= 532676608 bytes (about 500 megs). The solution is to make sure that
all LMAs in the executable are sane with respect to the @samp{loadaddr}
variable in your @file{.vmipsrc}, usually by adding any new sections
you find to either the .text, .data, or .bss section of the linker script.

@c This file is where the Invoking vmips and Customizing nodes are to be
@c found.  They are also used to create the vmips(1) man page.
@include invoke.texi

@c This file is where the Invoking vmipstool node is to be
@c found.  It is also used to create the vmipstool(1) man page.
@include vmipstool.texi

@node Programming, Debugging, Invoking vmipstool, Top
@chapter Programming

In this section we attempt to give some hints about writing code for
VMIPS.  They are primarily intended for assembly language programmers,
but should be helpful to anyone interested in the MIPS
architecture. This section will not replace a good MIPS reference; check
the "References" section for more information about these. However, any
help is appreciated for making this section more complete.

@section Delay slot handling

MIPS branch instructions' effects are delayed by one instruction;
the instruction following the branch instruction is always executed,
regardless of whether the branch is taken. This is a consequence of
the pipeline which is not important to virtual machine architecture,
except that it has to be emulated correctly.

VMIPS emulates delay slot handling by means of a tiny state machine, whose
state is called the delay state.  The virtual CPU can be in a delay state
of @code{DELAYING}, @code{DELAYSLOT}, or @code{NORMAL} at the beginning
of the call to @code{periodic()}. The VMIPS delay slot state machine's state
is displayed when you use the @option{dumpcpu} option. See the "Summary
of configuration options" section of the "Customizing" chapter for more
information about this option.

A delay state of @code{NORMAL} corresponds to execution in the non-branch case.

A delay state of @code{DELAYING} means that the instruction being executed
caused a branch to be taken, and the next instruction to execute is in
the delay slot. 

A delay state of @code{DELAYSLOT} means that the instruction just executed
was in the delay slot, and the next instruction to execute is the
branch target.  If there is an exception, the exception PC will be the
PC of the branch instruction, not of this one.

@node Debugging, Devices, Programming, Top
@chapter Debugging

VMIPS supports debugging through an interface to GDB, the GNU debugger.
GDB talks to VMIPS using its built-in remote serial protocol.
See the "Remote Serial" section of the GDB manual for details of the protocol.

If you want to take advantage of the VMIPS GDB interface, set the "debug"
flag on the command line. VMIPS will wait for you to attach GDB and type
"continue" at the GDB prompt before booting the ROM file.

To attach GDB to VMIPS, look for the line in the VMIPS startup message that
reads:

@example
Use this command to attach debugger: target remote 127.0.0.1:3371
@end example

(The host and port numbers (127.0.0.1:3371) may be different on your
machine.)  When VMIPS pauses and says "Waiting for connection from
debugger", open up GDB in another window or on another terminal on the
program you are debugging. Do not try to open GDB on the ROM file,
because GDB doesn't understand ROM files; rather, give GDB the name of 
the program you used to create the ROM file. Then type the "target remote..."
command that VMIPS printed out, and GDB will connect to VMIPS, which will
be stopped at the first instruction of your setup code. Then you can set
breakpoints, single step, or just let the program continue. VMIPS will return
control to GDB on exceptions.

Here is what the whole setup process looks like in VMIPS:

@iftex
@c A lot of these examples are too wide for regular @example.
@c This block is a dumb hack to make *this particular* @example use the regular
@c margins. See the definition of @cartouche to see how it works.
@begingroup
@let@nonarrowing=@comment
@end iftex

@example
% ./vmips -o debug boot.rom
Auto-size ROM image: 4096 words.
Running self tests.
Little-Endian host processor detected.
Self tests passed.
Use this command to attach debugger: target remote 127.0.0.1:33891
Mapping ROM image (boot.rom): 4096 words at 0xbfc00000 [1fc00000]
Attached SerialHost(fd 5) at 0x808cab8 to SPIMConsole [host=0x808cac8]
Attached SPIMConsole [host=0x808cac8] to phys addr 0x2000000
Connecting IRQ2-IRQ6 to console.
Mapped (host=0x401a4008) 1024k RAM at base phys addr 0

*************RESET*************

Waiting for connection from debugger.
Waiting for packet 0
@end example

@iftex
@endgroup
@end iftex

Here is what the whole setup process looks like in GDB:

@iftex
@c A lot of these examples are too wide for regular @example.
@c This block is a dumb hack to make *this particular* @example use the regular
@c margins. See the definition of @cartouche to see how it works.
@begingroup
@let@nonarrowing=@comment
@end iftex

@example
@iftex
@hfuzz=1000pt
@end iftex
% mips-dec-ultrix4.5-gdb boot.exe
GNU gdb 4.17
Copyright 1998 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "--host=i586-pc-linux-gnu --target=mips-dec-ultrix4.5"...
(gdb) target remote 127.0.0.1:33891
Remote debugging using 127.0.0.1:33891
__start () at setup.S:24
24              move $1, $0
Current language:  auto; currently asm
@end example

@iftex
@endgroup
@end iftex

@section GDB, VMIPS and Signals

Since VMIPS does not know what operating system you are running on it, and GDB
does not believe in hardware exceptions (only operating system signals), VMIPS
has its own mapping of hardware exceptions to signals.

The mapping is as follows: Each signal is followed by a list of the hardware
exceptions that map to it.

@table @var
@item SIGINT
@itemize
@item Interrupt
@end itemize

@item SIGSEGV
@itemize
@item TLB modification exception
@item TLB exception (load or instruction fetch)
@item TLB exception (store)
@item Address error exception (load or instruction fetch)
@item Address error exception (store)
@end itemize

@item SIGBUS
@itemize
@item Instruction bus error
@item Data (load or store) bus error
@end itemize

@item SIGTRAP
@itemize
@item SYSCALL exception
@item Breakpoint exception (BREAK instruction)
@item Processor reset (only at VMIPS startup)
@end itemize

@item SIGILL
@itemize
@item Reserved instruction exception
@end itemize

@item SIGFPE
@itemize
@item Coprocessor Unusable
@item Arithmetic Overflow
@end itemize

@item SIGHUP
@itemize
@item (Anything else.)
@end itemize
@end table

@subsection Startup behavior

Upon connecting to the VMIPS socket, gdb asks for the number of the
signal that stopped VMIPS. Of course, there was no exception, since no
instructions have executed, but we have to give a reason anyway. The
signal that is always returned is the signal corresponding to the
breakpoint exception -- hence the listing for processor reset in the
signal table above, even though reset is not really an ordinary exception.

@section GDB remote serial protocol implementation

The GDB remote serial protocol supports lots of packets, but VMIPS does
not support all of them.  The following subset of the GDB remote serial
protocol is implemented.

@itemize
@item packet 'g': Read registers
@item packet 'G': Write registers
@item packet 'm': Read memory
@item packet 'M': Write memory
@item packet 'c': Continue
@item packet 's': Single step
@item packet 'k': Kill target
@item packet 'H': Set thread
@item packet '?': What was the last signal?
@end itemize

@section ROM Breakpoints

@cindex ROM, breakpoints in
VMIPS supports the setting of breakpoints in ROM.  This would not be
extraordinary except that MIPS breakpoints are usually implemented by
GDB's remote serial protocol by overwriting instructions with MIPS break
instructions. VMIPS keeps a single bit for each word of ROM, in order
to tell whether that instruction is really a breakpoint. GDB keeps track
of setting and unsetting the breakpoints.

@node Devices, Extending, Debugging, Top
@chapter Devices

VMIPS comes with a few standard devices.

@section SPIM-compatible console device

The SPIM-compatible Console Device models a serial controller with
two 200-baud full-duplex communication lines and a 1 Hz clock providing
timer interrupts. This console device is currently the standard console
device used in VMIPS.

@subsection Memory-mapped registers

The SPIM-compatible console device communicates with the CPU by means
of a series of 9 32-bit-wide control and data registers, for a total
of 36 memory-mapped bytes. The control registers are used for enabling
and disabling specific devices' interrupt request mechanisms, and for
determining which device(s) is/are ready for data when polling or during
interrupt processing.

The following table details the offset of each register within the
console device's mapped memory:

@table @code
@item offset 0x00
Keyboard 1 Control

@item offset 0x04
Keyboard 1 Data

@item offset 0x08
Display 1 Control

@item offset 0x0c
Display 1 Data

@item offset 0x10
Keyboard 2 Control

@item offset 0x14
Keyboard 2 Data

@item offset 0x18
Display 2 Control

@item offset 0x1c
Display 2 Data

@item offset 0x20
Clock Control 

@end table

Within each control register, Bit 2 of each word is the Device
Interrupt Enable bit, and bit 1 is the Device Ready bit.  Only the
Device Interrupt Enable bits of the control registers are writable;
other bits must be written as zero. Only Device Interrupt Enable and
Device Ready are readable; other bits read as zero.

Within each data register, writes are allowed only to the
least-significant 8 bits; the other 24 bits read as zero and must be
written as zero.

@subsection Interrupts

With a SPIM-compatible Console Device configured, the following interrupt
lines are enabled.

@display
Interrupt line 2 (Cause bit 0x0400) is wired to the Clock
Interrupt line 3 (Cause bit 0x0800) is wired to the #1 Keyboard
Interrupt line 4 (Cause bit 0x1000) is wired to the #1 Display
Interrupt line 5 (Cause bit 0x2000) is wired to the #2 Keyboard
Interrupt line 6 (Cause bit 0x4000) is wired to the #2 Display
@end display

When any of the console devices becomes ready while its Device Interrupt
Enable bit is set, it also sets the appropriate bits in the Cause
register of CP0 and signals an Interrupt exception.

@subsection Display

The display data register is write-only.
On a write to the data register, the display becomes unready and writes
a char to the connected serial interface; it becomes ready again in 40
ms.

@subsection Clock

The Clock has no data register and becomes ready at most every second. A
read from the Clock Control register makes the clock unready. Writes to
the clock control register are as above.

@subsection Keyboard

The keyboard is initially unready; whenever the connected serial
interface has a char waiting on input, and the keyboard is unready,
the keyboard reads the char into its buffer, and becomes ready. If the
keyboard is ready for more than 40 ms., it will check the connected
serial interface again.  If there is another char available, it will
read it and save it in the buffer, writing over the one which was
originally in the buffer. No provision is made for detection of these
buffer overruns.  Updates to the keyboard buffer happen at most once
per instruction fetched.

The keyboard data register is read-only.  On a read from the data
register, if the keyboard is ready it becomes unready and returns the
byte in its holding buffer. If the keyboard data register is read while
the keyboard is unready, the data in the buffer is the same as when
the keyboard was last ready.

@section Standard clock device

This section documents the standard clock device for VMIPS.  It is
intended to support user programs' access to real time, for the
benefit of realistic user perceptions, and simulated time, for
repeatability of experiments. It also supports a hardware clock
interrupt, and provides access to TOY (i.e., Time of Year) for those
special occasions when you want the clock to tell you what time it is,
not just how fast things are going.

The reason this clock is to be preferred over the SPIM-compatible
console device's clock is because it provides much better resolution (1
MHz vs. 1 Hz).

@subsection Memory-mapped registers

The standard clock device  has 5 registers, configured by default to
be mapped into memory at address 0xa1010000. The following table defines
the layout of the memory-mapped clock device registers:

@table @code
@item offset 0x00
real time, seconds

@item offset 0x04
real time, microseconds

@item offset 0x08
simulated time, seconds

@item offset 0x0c
simulated time, microseconds

@item offset 0x10
control word
@end table

Writing any of the clock's time words is undefined.  Support for setting
the time from a MIPS program may be added in the future.

The control word  has 32 bits.  The least-significant bit, when set
(@code{CDC_INTERRUPTS_ENABLED} is defined as 0x00000001), enables the clock
interrupt. All other bits of the control word are currently reserved
and read as zero.  Writing any of the other bits of the control word
is undefined.

@subsection Interrupts

The standard clock device is connected to hardware interrupt line 7 in
the default configuration.

The `clockintr' option gives the frequency of clock interrupts, in
nanoseconds of simulated time.  (See the "Summary of configuration
options" section of the "Customizing" chapter for more information.)
When a clock interrupt is triggered, it will be deasserted during the
following instruction.

@subsection Real vs. simulated time

Real time is obtained using the host's @code{gettimeofday(2)} system
call, so it should run pretty close to whatever the host thinks the
current time is.  No sophisticated algorithms are used to calibrate the
real time clock, though.

The speed of simulated time is determined by the `realtime', `clockspeed',
and `timeratio' options. (See the "Summary of configuration options"
section of the "Customizing" chapter for more information.)  Increasing
the speed of simulated time is unlikely to make the simulator appreciably
faster.

@node Extending, Installation, Devices, Top
@chapter Extending

This chapter is intended to be a hacker's guide to adding or modifying
VMIPS functionality.

@section Road map to the VMIPS source code

This section is intended to help interested persons find various things
in the VMIPS source code, and get a general idea of how the various
software modules are structured.

The processing of command-line options and of options in your
@file{.vmipsrc} is directed by routines in @file{options.cc} and in class
@code{Options}. The default options and the option documentation is all
in @file{optiontbl.h}.

The memory mapping unit has a high-level interface to the rest of
the code, which is defined in @file{mapper.cc} and @file{mapper.h},
and in class @code{Mapper}.  The memory mapping unit uses a bunch of
low-level data structures, which are defined in @file{range.cc} and
@file{range.h}, in classes @code{Range} and @code{ProxyRange}. This is
meant to be logically and physically separate from the TLB, which is
implemented as part of the system control coprocessor.

The system control coprocessor (MIPS coprocessor zero) and the TLB
are implemented in @file{cpzero.cc} and @file{cpzero.h}, as class
@code{CPZero}.

There is a cache implementation in @file{cache.cc} and @file{cacheline.cc}
(classes @code{Cache} and @code{CacheLine}), but these modules are not
finished yet.

The CPU (class @code{CPU}) and the default exception handling behavior are
implemented in @file{cpu.cc} and @file{cpu.h}. Exception handling behavior
is an interface described by class DeviceExc (in @file{deviceexc.h});
the only really important feature of this class right now is the
@code{exception} instance method and its implementation in class
@code{CPU}.

The disassembler, which uses GNU libopcodes (part of GNU Binutils),
is in @file{stub-dis.cc}.

The SPIM-compatible console device, which is comprised of two serial line
TTYs and a clock, is in @file{spimconsole.cc} and @file{spimconsole.h}.

The standard clock device is in @file{clockdev.cc} and
@file{clockdev.h}.

@file{zschip.cc} contains an unfinished emulation of the Zilog Z85C30
serial chip, commonly found in Macintoshes and Suns.

The GNU debugger interface is separated into a high-level part (which
deals with the various debugger requests) in @file{debug.cc} and
@file{debug.h}, and a low-level part (which assembles and disassembles
the GDB remote serial protocol packets), in @file{remotegdb.cc} and
@file{remotegdb.h}.

Many parts of the VMIPS system have a central procedure which needs
to be run periodically in a loop in order to update the part of the
simulation that they are responsible for.  Any part of the VMIPS system
which needs to be called back periodically to update its state can
inherit from class @code{Periodic} (described in @file{periodic.h})
and implement the @code{periodic()} member function.  The @code{CPU}
class, for example, fetches, decodes, and executes one instruction each
time its @code{periodic()} function is called.  Devices, such as the
SPIM-compatible console device, use their @code{periodic()} function
check for and complete pending I/O and trigger interrupts as necessary.

The @code{vmips} class, implemented in @file{vmips.cc}, is used to tie
all the components of the system together.  This class, and specifically
its @code{run()} member function, is responsible for setting up and
configuring all system components and calling the @code{periodic()}
member function(s).  The vmips class is not a very smart or a very
flexible configuration mechanism; it will eventually be replaced with
a configuration language of some sort.

@cindex ROM bootstrap loader
@cindex ROM monitor
The ROM bootstrap loader code (also known as the ROM monitor) is in the
directory @file{sample_code/xmboot}.  The current ROM monitor uses the XMODEM
protocol.

The manual, and any random bits of hacking information which have not
yet been incorporated into the manual, are in the directory @file{doc}.

A bunch of interesting test cases are in the
directory @file{test_code}. Most of the interesting sample code is being
moved into the directory @file{sample_code}, but some interesting sample
code continues to be stored in the @file{test_code} directory.

Various scripts used by the maintainers to help maintain the code are
in the directory @file{utils}.

@section Endianness issues

There are no known bugs involving endianness issues.

However, when you are making extensions to VMIPS, it is important not to
assume that your host processor is little-endian (or to assume that it is
big-endian). The configuration procedure determines the endianness of the
VMIPS target and of the host processor, and will define the C preprocessor
symbol @code{BYTESWAPPED} if the two are different. You can then call the
@code{swap_word()} or @code{swap_halfword()} static methods of class
@code{Mapper} to do the translation between host and target, when necessary.

As you might expect, this is most important when dealing with reading from
memory or from memory-mapped devices.

Most endianness problems can be dealt with using the @code{BYTESWAPPED}
symbol, except those problems originating in third-party libraries which
you might hook up to VMIPS. If you are calling external code that has to
know whether to expect big-endian or little-endian instructions or data,
or whether the host processor is big-endian or little-endian, you can
use the C preprocessor symbols @code{TARGET_LITTLE_ENDIAN} and
@code{TARGET_BIG_ENDIAN} for the target, and testing for the presence or
absence of the definition of @code{WORDS_BIGENDIAN} for the host.

@section Memory-Mapped Devices

Memory-mapped devices must inherit from class @code{DeviceMap}.
They must have a constructor and a destructor, and 
override the following abstract methods:

@example
uint32 fetch_word(uint32 offset, int mode, DeviceExc *client);
uint16 fetch_halfword(uint32 offset, DeviceExc *client);
uint8 fetch_byte(uint32 offset, DeviceExc *client);
uint32 store_word(uint32 offset, uint32 data, DeviceExc *client);
uint16 store_halfword(uint32 offset, uint16 data, DeviceExc *client);
uint8 store_byte(uint32 offset, uint8 data, DeviceExc *client);
@end example

The meanings of the parameters are as follows:

@table @var
@item offset
Byte offset from the beginning of the device's memory-mapped region that is
being read or written. The width of the read (fetch) or write (store)
is either a word (4 bytes), halfword (2 bytes), or a single byte,
depending on the call. Since this value is a byte offset, if you want to
figure out which word of your device is being accessed, you should
divide it by 4.

@item mode
This tells you whether the memory access is a data load
(@code{DATALOAD}), data store (@code{DATASTORE}), or instruction
fetch (@code{INSTFETCH}). These constants are defined in
@file{accesstypes.h}. For narrow (< 1 word) fetches, the mode is always
@code{DATALOAD}. For stores, the mode is always @code{DATASTORE}.
The only case in which this is ambiguous is for the @code{fetch_word}
case, where mode may be either @code{DATALOAD} or @code{INSTFETCH}.
Most devices do not need to bother with the mode, except when there is an
illegal access. See the section on exception behavior, below.

@item client
Every memory access is requested by a client, which is responsible for
handling any exceptions which may arise. Any component of the VMIPS
system which may access memory must either inherit from class @code{DeviceExc}
(i.e., "a device which may handle exceptions"), or have a pointer to a device
which does. See the section on exception behavior, below.

@item data
When the client is storing a value, you will receive the value as the
@var{data} parameter.
@end table

@section Exception behavior

Whenever there is an exception,
the device must make the call
@example
client->exception(type, mode);
@end example

@var{Type} must be one of the standard MIPS exception codes, which are
defined in @file{regnames.h}, and elsewhere in this manual. @var{Mode}
is the mode of the memory access; see the table entry for @var{mode}
above.

Please note that you should not call the @code{exception} method in
order to generate a hardware interrupt (i.e., the Interrupt exception).
Interrupts are managed by class @code{IntCtrl}, and your device should
call the @code{assertInt} function to generate them.  See the
"Interrupt-generating devices" section for more details on what you
should do.

@subsection Coprocessors

If your device is part of a MIPS coprocessor, you should pass a third
argument to the @code{client->exception()} call, which is the number of
the coprocessor; it may meaningfully be 0, 1, 2, or 3. Ordinarily, that
is to say in situations not involving coprocessors, this parameter
defaults to -1 and does not need to be specified explicitly.

@cindex coprocessor zero
Coprocessor 0 is the MIPS system control coprocessor, responsible for
TLB and paging management. It is implemented as class @code{CPZero} in
@file{cpzero.cc} and @file{cpzero.h}. It has 16 registers, each of which
has some read-only bits and some read/write bits. Extension code should
not attempt to misrepresent itself as being coprocessor zero without a
good reason.

@cindex registers, read-only
One of the jobs of the @code{CPZero} class is to ensure that attempts to
write to these registers are only allowed to write to the bits which
are writable, so if you are interested in implementing read-only  and
read/write registers in your virtual hardware, look through @file{cpzero.cc}
for @var{read_masks} and @var{write_masks}.

@cindex coprocessors, floating-point
Coprocessor 1 is the floating point coprocessor, but it is not
implemented. It may, however, be implemented in the future. Volunteers
to begin such a task would be more than welcome.

@cindex coprocessors, default behavior
The default behavior of MIPS coprocessors 1, 2, and 3 in the VMIPS system
is to assume that they are not connected to the system and that accesses
to them should therefore trigger the @code{CpU} (Coprocessor Unusable)
exception.

@section Mapping memory-mapped devices

You can map memory-mapped devices at one location, or more than one
location, if you want.  The instantiation process is as follows. Assume
that @code{TestDev} is a memory-mapped device class which derives from
class @code{DeviceMap}, that @var{testdev} is an instance of class
@code{TestDev}, and that @var{physmem} is a @code{Mapper} (memory
manager) object.
 
@example
 	/* Test device at base phys addr 0x01000000 */
 	testdev = new TestDev();
 	physmem->add_device_mapping(testdev, 0x01000000);
@end example

@cindex memory-mapped devices, configuring
@cindex memory-mapped devices, specifying addresses for
Therefore, if you want to have multiple base-addresses for a
device, you can. You can add as many calls to the Mapper instance
method @code{add_device_mapping(device, addr)} as you
want. @var{device} is an instance of a class deriving from class
@code{DeviceMap}. @var{addr} is the physical address where you want the
device to appear in memory.

This code is generally executed as part of the @code{vmips->run()}
method in @file{vmips.cc}. Look there for more information and some
examples of what to do.

@section Interrupt-generating devices

@cindex interrupts
VMIPS provides support for virtual devices that generate hardware
interrupts to communicate with the processor. These virtual devices should
inherit from class @code{DeviceInt} (defined in @file{deviceint.h}). This
section outlines some information about how to write such virtual devices.

@subsection Connecting devices to the interrupt controller

@cindex interrupts, request lines for
There are 8 interrupt lines in the R3000/R3000A, 6 of which (7..2) are
hardware interrupts (readable by software), and the other 2 of which
(1..0) are software interrupts (readable/writable by software).

The class @code{IntCtrl} instance method @code{connectLine(irq,
device)} is used in @file{vmips.cc} to notify the interrupt
controller and the device that the interrupt line specified by @var{irq}
is connected to @var{device}.  @var{irq} must be one of the hardware
interrupt constants defined in @file{deviceint.h} and @var{device}
must be an object of a class deriving from @code{DeviceInt}.

@subsection Generating and cancelling interrupt requests

@cindex interrupts, generating requests for
The class DeviceInt instance method @code{assertInt(irq)} is used to request an
interrupt from the processor.  Your device should only request interrupts
that have previously been connected to it using the interrupt controller
(see above). Your device may share an interrupt request line with another
device.  In practical terms, asserting an interrupt request line will
cause a trap to the general exception vector before the next instruction.

@cindex interrupts, cancelling requests for
The instance method @code{deassertInt(irq)} will turn off
the interrupt request for your device; this should be done when the
condition that caused the device to request an interrupt has become
satisfied. Note that this does not necessarily imply that the interrupt
request for the processor will be turned off, as there may be another
device trying to use that interrupt request line.

For both calls, the IRQ parameter must be one of the hardware interrupt
constants defined in @file{deviceint.h}.  It is not a good idea to use the
general @code{exception()} method to cause interrupt exceptions, because this
could cause excess interrupts to be generated.

The place where you should make these calls and do these checks is when
your device's code is called through the @code{periodic()}
callback. Your device will get @code{periodic()} calls fairly often.

@subsection Software interrupts vs. hardware interrupts

@cindex interrupts, reserved for software
Two of the interrupt lines (IRQ 0 and 1) are reserved for software
use. Only the interrupts which are not reserved for software use (IRQ
2 through 7) may be triggered by VMIPS devices.

@subsection Turning interrupts off and on

@cindex interrupts, enabling and disabling
There is a global Interrupt Enable bit for the whole system; this is the
IEc (Interrupt Enable (current)) bit, bit 0 (mask 0x001) of the Status
register (coprocessor zero register 12).  If this bit is turned off,
no interrupt will be triggered. Be sure to turn on your Interrupt Enable
and Interrupt Mask (below) bits when you are testing your new
interrupt-generating device.

@cindex interrupts, masking
Additionally, bits 15 - 8 (mask 0x0ff00) of the Status register are
individual Interrupt Mask bits. Each bit represents a global interrupt
enable/disable bit for the entire system per interrupt-request line. For
example, if you turn off bit 10 of this register (mask 0x0400), the IRQ2
line will be disabled for the whole system.

Finally, it is not uncommon for individual devices to have their own
interrupt enable/disable bits that you can set or clear. See the
documentation for each individual device for more information.

@section Weird things

@subsection Branch on Coprocessor Zero True/False
@cindex coprocessor zero, branch instructions
@cindex system control coprocessor, branch instructions
These instructions are not supposed to cause reserved instruction
exceptions, even though the behavior of BC0F and BC0T instructions on
MIPS-1 machines is not specified in most canonical references.

On some DEC MIPS machines, the coprocessor 0 condition bit (which BC0F
and BC0T test) is wired to the external write-buffer-empty bit; that is,
when all stores have completed, the write buffer becomes empty, and the
bit goes to true. This makes it possible for a hacker to write the line
@samp{1: bc0f 1b} and thereby loop until the write buffer is empty.  However,
this is not true of all DECstations, or of the Sony NEWS 3400.

The coprocessor zero condition bit has an entirely different use on the
R4400 and compatible processors; it is used to tell when you got a cache
hit with a CACHE operation. The R10000 also implements this condition,
but the bit is not wired to the coprocessor zero condition.

Since VMIPS does not support CACHE operations, and does not have a write
buffer, VMIPS emulates the case where the CpCond bit for CP0 is always
TRUE, i.e., applications that look for the writebuffer will find that
it is always empty.

@node Installation, Reporting Bugs, Extending, Top
@appendix Installation

The VMIPS build process assumes that you have a full set of GNU
MIPS cross compilation tools installed, because you'll need them to do
anything useful with VMIPS. For a concise summary of how to build
the necessary MIPS cross tools, read "Building MIPS Cross Tools",
below.

VMIPS uses the GNU Autoconf/Automake system for configuration management.
This provides the familiar @command{configure} shell script interface for
setting configuration variables. For more information about the special
options that VMIPS @command{configure} accepts, read on, or give the
@option{--help} option to @command{configure} for an abridged version.

@section Building from CVS

@cindex configure, missing
@cindex configure, creating
If you retrieved your sources from the CVS repository, you will need
Automake version 1.4 or later, Autoconf version 2.13 or later, and
libtool 1.2f or later. You will need perl 5 to build the documentation.
Your distribution will be missing many important files, including
@command{configure}. To generate these, run @command{utils/bootstrap}. To
automatically run configure once it has been generated, you can run
@samp{utils/bootstrap -c CONFIGURE-ARGS}.

@section Options that configure supports

@pindex configure
You will need to tell @command{configure} the configuration prefix you used
to install the MIPS cross tools, by specifying it as the value to
the @option{--with-mips} argument. For example, if your MIPS cross compiler
is @file{/opt/mips/bin/mips-dec-ultrix4.3-gcc} and your MIPS-targeted
libopcodes libtool library (which should have been installed by the
binutils Makefile) is @file{/opt/mips/lib/libopcodes.la}, then you
should specify @option{--with-mips=/opt/mips} on the @command{configure}
command line.

@cindex configure, options supported by
Other options that "configure" supports are as follows:

@table @option
@item --with-mips=MDIR
Specify installation prefix of MIPS cross tools (default MDIR = /opt/mips).

@item --with-mips-lib=DIR
Specify path to MIPS cross tools' libraries (default MDIR/lib).

@item --with-mips-bin=DIR
Specify path to MIPS cross tools' executables (default MDIR/bin).

@item --with-mips-include=DIR
Specify path to MIPS cross tools' includes (default MDIR/include).

@item --with-mips-bfdtarget=TARG
Specify MIPS cross tools BFD target name (defaults to the first target
listed in the output of objdump -i). Normally you can let configure
guess this, unless you built your MIPS tools for a target (mips-ecoff or
mips-elf, for example) which supports both big-endian and little-endian
data.

@item --with-mips-endianness=VAL
Specify endianness of the VMIPS simulated machine, which must match the
MIPS cross tools target's endianness.  VAL may be specified as @code{big}
or @code{little}.  It is best to let configure guess this (using objdump
-i), unless you have reason to believe it is guessing wrong, because if
you get it wrong, vmipstool may compile ROMs that do not run correctly
under vmips.

@item --disable-debug 
Strip debugging symbols and turn on all the compiler optimizations.
The default is not to do this (i.e., leave in the debugging symbols, 
and turn off all the compiler optimizations.)

@item --disable-tty
Do not include (default=include) support for the emulated serial interface.

@end table

@section Building MIPS Cross Tools

First decide on an installation prefix. The following examples will
use the prefix "/opt/mips", as above.

@cindex GNU Binutils, obtaining
Download a copy of Binutils, from any GNU mirror, or from the URL:
@display
@url{ftp://sources.redhat.com/pub/binutils/releases}
@end display
We recommend getting version 2.10.1. The file you will need would be
named @file{binutils-2.10.1.tar.gz}.

Build binutils by running the following commands. We recommend
@code{--disable-nls} because some recent versions do not build correctly with
NLS (linking against @file{libopcodes.a} results in unresolved symbols.)

@example
./configure --target=mips-dec-ultrix4.3 --prefix=/opt/mips \
 --disable-nls --enable-shared
make
make install
@end example

Save a copy of @file{include/dis-asm.h} from the Binutils source distribution.
You'll need to install it as @file{include/dis-asm.h} in the VMIPS source
distribution, in order to ensure compatibility between the version of
Binutils you used and VMIPS.

@pindex gcc
@cindex GNU Compiler Collection, obtaining
Download a copy of the GNU Compiler Collection (@command{gcc}) from
any GNU mirror, or from the URL:
@display
@url{ftp://gcc.gnu.org/pub/gcc/releases}
@end display
We recommend version 2.95.2. Download the file @file{gcc-2.95.2.tar.gz}.

@cindex GNU Compiler Collection, installing
You can read the documentation for building the compiler by pointing
your World-Wide Web browser at @url{http://gcc.gnu.org/install}.
When you encounter difficulties, you should consider consulting the
documentation for building the compiler, because it is more complete
than the following summary.

@enumerate
@item Unpack the sources. Let's say you unpack them in @file{/usr/build},
creating the directory @file{/usr/build/gcc-2.95.2}.

@item Create the build directory @file{/usr/build/gcc-mips-build}.

@cindex GNU Compiler Collection, configuring
@item First, add the directory @file{/opt/mips/bin} (where you just installed
Binutils) to your path, so that the compiler configuration process can
find your MIPS-targetted assembler and linker.

@item Configure the compiler. Change to the directory
@file{/usr/build/gcc-mips-build} and issue the following command. (The
back-slash characters represent the usual Unix shell convention of continuing
a command on the following line, and are inserted for typesetting purposes.)

@example
../gcc-2.95.2/configure --target=mips-dec-ultrix4.3 \
 --prefix=/opt/mips --with-gnu-as --with-gnu-ld \
 --disable-threads --disable-shared
@end example

@item If the configuration step fails, make sure you have a working native
compiler, and/or try a different version of gcc. Otherwise, proceed to compile
the compiler:

@example
make -k MAKE='make -k TARGET_LIBGCC2_CFLAGS=-Dinhibit_libc' cross 
make -k LANGUAGES=c install
@end example

The reason @samp{make -k} is required is because some parts of the gcc
toolkit may fail to build, but the compiler itself may be OK.

The @option{-Dinhibit_libc} option is required when you are building
the compiler in the absence of a MIPS C library, as is often the case
with VMIPS users.

Do not be alarmed by errors in building or installing the compiler;
the cross compiler install interface is less than polished.

@item You should be able to use the newly-installed  compiler to compile
(but not link) a program that does not use any C library functions.
If this works, you should be able to use the cross tools you have just
built for VMIPS.

If you want to build a MIPS C library, you can also do that now, but it is
not strictly required for many useful VMIPS tasks. Some persons have
reported success using the "newlib" C library from Cygnus. The GNU C
Library (glibc) is fairly difficult to build. Instructions for building
a C library will appear here soon.

@end enumerate

@node Reporting Bugs, Future Directions, Installation, Top
@appendix Reporting Bugs

We are always interested in hearing about VMIPS bugs.
Please send mail to @code{vmips@@sartre.dgate.org} and tell us about them.
Please include at least the following information:

@itemize
@item your operating system
@item your host processor type
@item your C++ and C compiler make and version
@item the version of VMIPS you are using
@item how you configured VMIPS
@item how to trigger the bug
@item what you expected to see
@item how what you saw differed from what you expected to see
@item how you think it could be fixed (send a patch if you have one)
@end itemize

@node Future Directions, References, Reporting Bugs, Top
@appendix Future Directions

@section Version 1.1 targets

@subsection Caches

The caches are not currently finished, and not connected to the rest of
the memory subsystem.

Arguments in favor of finishing the caches include the fact that operating
systems tend to expect them, and you can learn some things about how many
cache misses your code incurs if you simulate them. Arguments in favor of
ditching the caches center around the performance penalty that simulating
them would cause.

Finishing the implementation of the cache is a two-part task:
@enumerate
@item Implement cache "store partial" mode.
@item Implement the non-"store partial" mode; i.e., where a store causes the
cache line to be invalidated unconditionally. (pp. 5-5 & 5-6 in MIPS RISC
Architecture).
@end enumerate
Understanding how to do this is probably best accomplished by first reading
@file{cache.cc} and @file{mapper.cc}.

@subsubsection Cache behavior and the Status register

CP0 implements two Diagnostic Status bits in the Status register called
IsC and SwC; they can be used by the OS to determine the cache geometry
exactly, for example. These can be tested by the appropriate accessor
functions in cpzero.cc.

Cache isolation (IsC = 1) means the cache is never refilled and all
accesses are considered hits; stores write into the cache and do not
write into memory.

Cache swapping (SwC = 1) means the instruction cache and data cache
are switched, so that instruction fetches go through the data cache
and load/store instructions go through the instruction cache.

@subsection Other version 1.1 targets

@enumerate
@item Make the SPIM console device more efficient. Currently the code spends
36% of its time in calls to @code{select()} and 35% in all the emulation
functions, which is unacceptably slow. Probably we will want to use a
separate thread to cause interrupts instead of polling. We'll likely
have to restructure the interrupt controller for this.
@itemize
@item A thought I had was to use a separate thread for everyone who wants to
have @code{periodic()} called.
@item Michael Constant suggesting using @code{FIOASYNC},
@code{sigaction()} with @code{SA_SIGINFO}, and handling @code{SIGPOLL}
by dispatching to the correct interrupt generator.  This would be both
more portable and easier to understand than threads.
@end itemize

@item Make the build process suck less. Right now it requires drawing a
pentagram around your computer on the night of a full moon with torches blazing, not
to mention a very close synchronization between versions of gcc,
binutils, gdb, and whatever else you are trying to use. It may be a good
idea to build a "combined source tree" including gcc, vmips, gdb, and
binutils source together for people to install. 

@item Generally make things faster. Some other strategies for making things faster:
@item The way we do options must die. Replace it with 
@itemize
@item a bunch of global (or instance-variable-local) variables, to replace class Options, and
@item a real configuration language (to replace
@file{.vmipsrc}). Probably Tcl or Guile Scheme will be used. Tcl is attractive
because it is well-integrated with the Cygnus combined source trees. 
Guile Scheme is attractive because it is the official GNU language for
extension.
@end itemize
@item The console device stuff, above.
@item Galen's dynamic recompilation stuff, or a suitable replacement
using GNU Lightning.
@item We need to have a benchmark suite in place in order to quantify all this.
@item Some of the data structures could use some improvement:
@itemize
@item memory mapping range list
@item maybe tlb
@end itemize

@item Write a testing framework. DejaGNU would be the place to begin.

@end enumerate

@section Version 1.5 targets

@enumerate
@item When configuring a serial device, the user should be able to select a
machine-dependent serial front-end (e.g., unix-xterm, posix-serial,
mac-serial, mac-ttywidget, etc.) and a machine-independent serial
back-end (zilog-z85c30, spim-console, etc.) These would be good to
implement using shared libs. Also, modularizing the CPU, memory mapper
and other pieces (freezing APIs, building as shlibs) would be a Very
Good Thing Indeed. (In general, we need to throw out vmips.cc and replace
it with a smart configuration mechanism, probably based on Guile Scheme or Tcl.)

@cindex debugger interface, future directions
@item Ideally, debugger should be able to be attached at any time, without the user
having had to think of it. Delay the debugging interface initialization until
a connection is received?

@item NLS (i.e., i18n).  This will require some un-American activities.

@end enumerate

@section Version 2.0 targets

@enumerate
@item One thing VMIPS could really use is an emulation of the MIPS R3010 FPU.
A good way to get started on building an FPU would be to use
SoftFloat: @url{http://www.cs.berkeley.edu/~jhauser/arithmetic/softfloat.html}.

@end enumerate

@section Other things to do

Future directions which are not associated with any particular
release target:

@enumerate
@cindex ROM monitor, future directions
@item For the ROM monitor, support TFTP (UDP) over SLIP with some fixed
kernel name and a configurable address (but probably not ARP).

@item For the @code{ZSChip} module, finish the emulation, and validate
it against some stable free-software serial drivers.

@item For the debugging interface, support more and
more different GDB remote serial protocol packets. It would have been
nice, for example, to use the remote Z-packet interface for breakpoints.

@item Full MIPS32 support.

@item Checkpoint and restart of simulations.

@item Develop a patch for gas to support software register names.
gas supports $sp and $gp but not, say, $t0.

@item Consolidate some of the .h files that just contain huge
lists of useful constants.


@end enumerate

@node References, Copying, Future Directions, Top
@appendix References

Silicon Graphics, Inc. @cite{The R10000 Microprocessor
User's Manual - Version 2.0.} Available from
@display
@url{http://www.sgi.com/processors/r10k/manual.html}
@end display
as of May 24, 2001.

@quotation
This is a good reference about a typical 64-bit MIPS processor,
and also has some useful application notes. However, the processor it
describes is currently much more advanced than the VMIPS simulation.
@end quotation

Silicon Graphics, Inc. @cite{SGI
TechPubs Library: The ABI(5) manual page.} Available from
@display
@url{http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0650&db=man
&fname=/usr/share/catman/p_man/cat5/abi.z}
@end display
as of May 24, 2001.

@quotation
This is a short manual page about the three prevalent MIPS ABIs
(application binary interfaces), termed O32, N32, and N64.
@end quotation

Silicon Graphics, Inc. @cite{SGI
TechPubs Library: The MIPS_EXT(5) manual page.} Available from
@display
@url{http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?cmd=getdoc&
coll=0650&db=man&fname=5%20mips_ext}
@end display
as of May 24, 2001.

@quotation
This short manual page is a good summary of the differences between
the various MIPS ISA levels (MIPS-II, MIPS-III, MIPS-IV).
@end quotation

Kane, Gerry, and Joe Heinrich. @cite{MIPS RISC Architecture.} Upper
Saddle River, New Jersey: Prentice-Hall, 1992.

@quotation
This is a good all-around reference for the 32-bit MIPS
processors which VMIPS is modelled upon, and it includes a complete list
of all the 32-bit MIPS-II instructions as well as a description of the
MIPS TLB, virtual memory, exception behavior, and caches.
@end quotation

Sweetman, Dominic.  @cite{See MIPS Run.} San Francisco: Morgan Kaufmann
Publishers, 1999.

@quotation
This is a general reference in the style of Kane and Heinrich,
but updated for the MIPS-III, MIPS-IV, and MIPS-V ISAs, and written
in a much more experienced and less minimalist style, with attempts to
include useful pieces of MIPS lore.
@end quotation

MIPS ABI Group Incorporated.  MIPS Processor ABI
Conformance Guide, Version 1.2.2, 1996. Available at
@display
@url{http://www.eagercon.com/resources/MIPSabi12/toc.html}
@end display
as of June 3, 2001.

@quotation
Describes, among other things, a position independent coding model (PIC) for
MIPS.
@end quotation

Delorie, DJ.  DJGPP COFF Spec. October, 1996. Available from
@display
@url{http://www.delorie.com/djgpp/doc/coff}
@end display
as of June 3, 2001.

@quotation
A good online reference for the COFF file format, a form of which was heavily
used on DEC MIPS implementations.
@end quotation

Tool Interface Standard Committee.  Executable and Linking
Format Specification. Version 1.2, May 1995. Available from
@display
@url{http://www.linuxbase.org:80/spec/refspecs/elf.pdf}
@end display
as of June 3, 2001.

@quotation
An online reference for the ELF file format, now the preferred object
file format for Unix systems.  This document is highly Intel
architecture-specific, but it provides a lot of useful background material.
@end quotation

The Santa Cruz Operation, Inc. System V Application Binary Interface:
MIPS RISC Processor Supplement. 3rd ed., 1996. Available from
@display
@url{http://www.linuxbase.org/spec/refspecs/mipsabi.pdf}
@end display
as of June
4, 2001.

@quotation
The part of the System V application binary interface guide that pertains
specifically to MIPS RISC processors.
@end quotation

Also worth checking out is
@display
@url{http://www.mips.com/publications/index.html}
@end display
which points to many MIPS Technologies, Inc. publications.

@node Copying, Index, References, Top
@appendix Copying

VMIPS and its source code are governed by the GNU General Public License,
which you should have received a copy of along with VMIPS. It is in the
source code distribution in the file @file{COPYING}.

VMIPS's documentation is governed by the GNU Free Documentation License;
see below for details.

@include fdl.texi

@node Index, , Copying, Top
@unnumbered Index

@c About Texinfo Indices
@c ---------------------
@c
@c Texinfo supports 6 indices. In the vmips manual, they are all merged into
@c a single index, namely, the concept index.  Each index has a command
@c used to add entries to it, and a two letter code used in @printindex
@c and @syncodeindex.  @printindex is used at the end of the manual to
@c print the index.  @syncodeindex is used at the beginning of the manual
@c to merge indices.
@c 
@c A "concept index" listing concepts that are discussed.  `@cindex CONCEPT'
@c makes an entry in the concept index for CONCEPT.  `cp' is the @printindex
@c code.
@c 
@c A "function index" listing functions (such as entry points of libraries).
@c `@findex FUNCTION' makes an entry in the function index for FUNCTION.
@c `fn' is the @printindex code.
@c 
@c A "variables index" listing variables (such as global variables of
@c libraries).  `@vindex VARIABLE' makes an entry in the variable index
@c for VARIABLE.  `vr' is the @printindex code.
@c 
@c A "keystroke index" listing keyboard commands.  `@kindex KEYSTROKE' makes
@c an entry in the key index for KEYSTROKE.  `ky' is the @printindex code.
@c 
@c A "program index" listing names of programs.  `@pindex PROGRAM' makes an
@c entry in the program index for PROGRAM.  `pg' is the @printindex code.
@c 
@c A "data type index" listing data types (such as structures defined
@c `@tindex DATA TYPE' makes an entry in the data type index for DATA TYPE.
@c `tp' is the @printindex code.

@printindex cp

@contents
@bye
