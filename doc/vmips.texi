\input texinfo      @c -*- texinfo -*-
@c %**start of header
@setfilename vmips.info
@settitle VMIPS Programmer's Manual
@c %**end of header

@ifinfo
This is the VMIPS Programmer's Manual, Zeroth Edition, for version 1.0-alpha.

Copyright @copyright{} 2001 Brian R. Gaeke.
@end ifinfo

@titlepage
@center @titlefont{VMIPS Programmer's Manual}
@page
@vskip 0pt plus 1filll

@strong{Warning: This is an unfinished prerelease version of the
documentation, dated @today{}. This documentation is entirely
preliminary, and doesn't cover everything that the final documentation
will have to.  Eventually it should grow into a more comprehensive user-
and programmer-level document.}

@vskip 0pt plus 1filll
Copyright @copyright{} 2001 Brian R. Gaeke.
Permission is granted to copy, distribute and/or modify this
document under the terms of the GNU Free Documentation License,
Version 1.1 or any later version published by the Free Software
Foundation; with no Invariant Sections, no Front-Cover Texts and
no Back-Cover Texts.  A copy of the license is included in the
section entitled "GNU Free Documentation License".
@end titlepage

@ifnottex
@node Top, Overview, , (dir)
@top
This is the VMIPS Programmer's Manual, Zeroth Edition, for version 1.0-alpha.

@strong{Warning: This is an unfinished prerelease version of the
documentation, dated @today{}. This documentation is entirely
preliminary, and doesn't cover everything that the final documentation
will have to.  Eventually it should grow into a more comprehensive user-
and programmer-level document.}

Copyright @copyright{} 2001 Brian R. Gaeke.

@menu
* Overview::              The rationale for VMIPS.
* Getting Started::       4 simple steps to building VMIPS programs.
* An Example::            Hello, World on VMIPS.

* Building Programs::     What you need to know when compiling for VMIPS.
* Invoking vmips::        Starting and stopping the simulation.
* Customizing::           The .vmipsrc file.
* Debugging::
* Extending::

* Installation::
* Reporting Bugs::
* Copying::

* Concept Index::
@end menu
@end ifnottex

@comment node-name, next,          previous, up
@node Overview, Getting Started, Top, Top
@chapter Overview

VMIPS is a simulator for a machine compatible with the MIPS R3000 RISC
architecture. VMIPS consists entirely of software; no special hardware is
required to run programs on VMIPS---that is, VMIPS is a virtual machine.

Since VMIPS is based on an already-existing architecture, it is relatively
easy to find tools to build programs that will run on VMIPS.

VMIPS is easily extended by programmers to include more virtual devices,
such as frame buffers, disk drives, etc. VMIPS is written in C++ and uses
a fairly simple class structure. Furthermore, VMIPS is intended to be a
"concrete" virtual machine which its users can modify at will---"concrete"
meaning that it maintains a tight correspondence between its structures
and structures which actually appear in modern physical computer hardware.
For example, a programmer who wished to modify the CPU simulation could easily
extract the "CPU" class from the VMIPS source code, and replace it with one
which was more to his/her liking.

VMIPS is also designed with debugging and testing in mind, offering
an interface to the GNU debugger GDB by which programs can be debugged
while they run on the simulator. As such, it is intended to be a practical
simulator target for compilers and assembly language/hardware-software
interface courses.

VMIPS is free software. This means that we encourage you to share it with
everyone, but we do not give you the freedom to restrict others from sharing
it with everyone. For a comprehensive explanation please read the GNU General
Public License.

MIPS and R3000 are registered trademarks of MIPS Technologies Inc.

@node Getting Started, An Example, Overview, Top
@chapter Getting Started

Step 0. If VMIPS is installed on your system, you can start building
programs with it right away.  Otherwise, you (or your system
administrator) will have to compile VMIPS first; see the appendix on
Installation.

Step 1. First, compile your program. You should have a MIPS cross-compiler
available.  VMIPS supports the GNU C Compiler; most installations of
VMIPS will also have an installation of the GNU C Compiler targetting
the MIPS architecture.  Your easiest interface to the C compiler will
probably be through the vmipstool program; to run the MIPS compiler that
VMIPS was installed with, use the "vmipstool --compile" command.

Step 2. Link your program with any support code necessary. VMIPS comes
with some canned support code, in the share/setup directory, or you
can write your own support code. VMIPS comes with a linker script for
simple standalone programs, which you can run with "vmipstool --link",
or you can write your own linker script.

Step 3. Build a ROM image. This is necessary because the current version of
VMIPS does not read in executables. Most real machines don't; they have
an embedded program on a piece of flash ROM that reads in the first
executable and runs it. This makes development a little more realistic, but
not quite so convenient; this may change in the future, but for now it's
necessary. To build a ROM image, use the script that comes with VMIPS, by
running "vmipstool --make-rom".

Step 4. Start the simulator using "vmips ROMFILE", where ROMFILE is
the name of your ROM image.  Your program should run to completion,
and if you are using the canned setup code that comes with VMIPS, 
the simulator should halt when it hits the first "break" instruction, which
should happen right after your "entry" function returns.

@node An Example, Building Programs, Getting Started, Top
@chapter An Example

Let's assume you have vmips already compiled, and that you have some setup
code in "setup.s", and a standalone program (i.e., not one meant to run under
an operating system) in "hello.c". 

First assemble the setup code.
@example
	vmipstool --assemble -o setup.o setup.s
@end example

Compile your program:
@example
	vmipstool --compile -c hello.c
@end example

Then, link your program and the setup code together to produce an executable:
@example
	vmipstool --link -o hello setup.o hello.o
@end example

Build a ROM image from the executable:
@example
	vmipstool --make-rom hello hello.rom
@end example

Run the program.
@example
	vmips hello.rom
@end example

The program will terminate, by default, when your setup code generates a
breakpoint exception (using the "break" instruction, for example). This
termination condition can be changed by adding one of the "halt" options to
the file ".vmipsrc" in your home directory.

@node Building Programs, Invoking vmips, An Example, Top
@chapter Building Programs

@section Source Languages

Programs for VMIPS are generally built out of C or assembly-language source
code. It is theoretically possible to use C++ or other languages, but the
infrastructure required has not yet been investigated or documented.

@section ROM Programs

The easiest way to get VMIPS to run a program is to install that program as
the VMIPS ROM. Building a C program as a ROM requires that you link it with
some setup code.

@section Default Setup Code

This section describes the default VMIPS setup code.  It also describes
the minimal set of things you need to do before you can run C code
from the ROM, since that is the intended purpose of the default VMIPS
setup code.

Start by clearing out registers and TLB entries.

Set yourself up a stack pointer ($sp). Usually this can just be some
number of megabytes above the end of your code's data segment.  You can
get the address of the end of your code's data segment from your linker
script.

Set up your globals pointer ($gp), if your code uses global data.
You can get the right address from your linker script.

If you have writable data in ROM, your C code probably doesn't realize
that it's in ROM, and it will want to write to it. You should copy the
writable data to RAM. There is code to do this in the canned setup code
provided with VMIPS.

Finally, your setup code should finish by calling the entry point of your
C code. Usually this will have a name like "entry"; using the name "main"
is not recommended, because many versions of GCC assume that they can
call standard C runtime setup functions (crt0.o) from the beginning of
"main". You may or may not want this.

When the C code returns, you will probably want to halt the machine;
the default way to do this is by executing a break instruction.

One last thing to include in your setup code is a boot-time exception
handler of some sort. An absolutely minimal exception handler is a break
instruction at address 0xbfc00180, which will halt the machine on any
exception.

@section Linking

You want the text section of your program to start with the setup
code, so link in the setup code first.

You want the setup code to start at 0xbfc00000, which is the MIPS
reset exception vector. In practical terms, when VMIPS starts up,
it will reset. When VMIPS resets, it jumps to 0xbfc00000, which is
the beginning of your setup code.

@section Common Errors in Compilation

If the linker complains about not being able to find the symbol _gp_disp,
you should turn on the GCC option -mno-abicalls. _gp_disp is used by
the SGI N32 ABI for MIPS ELF.  One reliable reference source claims,
``_gp_disp is a reserved symbol defined by the linker to be the distance
between the lui instruction and the context pointer.'' The GNU linkers
currently in use do not appear to support this function.

@node Invoking vmips, Customizing, Building Programs, Top
@chapter Invoking vmips

@node Customizing, Debugging, Invoking vmips, Top
@chapter Customizing

@section VMIPS options

The VMIPS simulator gets runtime options from four different sources,
in this order: first, it checks its compile-time defaults, which are
set by the site administrator in the source file @file{optiontbl.h}. Then,
the system-wide configuration file is read; usually this is in
@file{/usr/local/share/vmipsrc}, but it may have been moved by the site
administrator. (This is configurable in the source file @file{options.h}, and
by specifying the --prefix and --sharedir options to the GNU @command{configure}
script when building VMIPS.) Next, it checks the user's own configuration
file, usually the file @file{.vmipsrc} in your home directory. Last, it
reads the command line, and gets any options listed there.

@section Format of the configuration file

The configuration file may contain as many options per line as you want,
provided no line exceeds BUFSIZ (usually 1,024) characters.  Whitespace
separates options from one another. A string or number option named
NAME can appear as NAME=VALUE, where VALUE is the string or number
in question. If the number begins with 0x, it will be interpreted
as a 32-bit hexadecimal number, and if it begins with 0, it will be
interpreted as octal. Otherwise, it will be interpreted as a decimal
number. Numbers are always unsigned. A Boolean option named NAME can
appear as either NAME (to set it to TRUE) or noNAME (to set it to FALSE).

@section Summary of configuration options

The following is a list of the configuration options present in this
version of VMIPS.

@include options.texi

@node Debugging, Extending, Customizing, Top
@chapter Debugging

@node Extending, Installation, Debugging, Top
@chapter Extending

@node Installation, Reporting Bugs, Extending, Top
@appendix Installation

@node Reporting Bugs, Copying, Installation, Top
@appendix Reporting Bugs

@node Copying, Concept Index, Reporting Bugs, Top
@appendix Copying

@node Concept Index, , Copying, Top
@unnumbered Concept Index

@printindex cp

@contents
@bye
