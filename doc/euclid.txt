
A simple test case for VMIPS
----------------------------

 The program in "test_code/tester.c" is a fixed-data, register
 implementation of the Euclidean Algorithm for computing the greatest
 common divisor. Here is a list of the (ten) calculations that it
 completes for a = 120,923,429 and b = 30,030:

   120923429 % 30030 = 22649
       30030 % 22649 = 7381
        22649 % 7381 = 506
          7381 % 506 = 297
           506 % 297 = 209
           297 % 209 = 88
            209 % 88 = 33
             88 % 33 = 22
             33 % 22 = 11
             22 % 11 = 0

 Here is the relevant function from tester.c:

    void tester(void)
    {
	    register int a, b, c;
    
	    a = 120923429;
	    b = 30030;
	    do {
		    c = a % b; a = b; b = c;
	    } while (c);
    }

 The following is an assembly language dump of the program from
 "romdis" (a shell script which calls objdump), followed by a trace
 of the instructions as executed by VMIPS when you run the "tester.c"
 program. I compiled it with "gcc -O3 -c -o tester.o tester.c" and "mkrom
 tester.o"; this latter command uses objcopy and dd to extract the code.
 (This particular build of VMIPS had a disassembler bug which caused it
 not to compute branch addresses correctly, but the branch delay slot
 emulation code was correct so the code ran correctly.)

    4000:	3c030735 	lui	$v1,0x735
    4004:	34632525 	ori	$v1,$v1,0x2525
    4008:	2404754e 	li	$a0,30030
    400c:	14800002 	bnez	$a0,0x4018
    4010:	0064001a 	div	$zero,$v1,$a0
    4014:	0007000d 	break	0x7
    4018:	2401ffff 	li	$at,-1
    401c:	14810004 	bne	$a0,$at,0x4030
    4020:	3c018000 	lui	$at,0x8000
    4024:	14610002 	bne	$v1,$at,0x4030
    4028:	00000000 	nop
    402c:	0006000d 	break	0x6
    4030:	00001010 	mfhi	$v0
    4034:	00801821 	move	$v1,$a0
    4038:	00402021 	move	$a0,$v0
    403c:	1480fff3 	bnez	$a0,0x400c
    4040:	00000000 	nop
    4044:	03e00008 	jr	$ra

 The key thing about this code is that it doesn't have any references
 to memory, and doesn't call any procedures or do anything that needs
 the stack.  Hence, it can operate without any loading or storing
 beyond that which is required for instruction fetching from uncached,
 non-TLB-mapped memory.

 Here's the trace, instruction-by-instruction. The actual output from
 VMIPS is not necessarily this pretty, but it's configurable using
 several run-time options.  You can see from this that branches happen
 the instruction after they're executed, just like on a real MIPS (and
 as opposed to SPIM). I have omitted the instruction-by-instruction
 register dumps, as they tend to make the output rather verbose.

       PC            Instr    Disassembly
       -------------------------------------------
    PC=0xbfc00000    3c030735 lui $3, 1845
    PC=0xbfc00004    34632525 ori $3, $3, 9509
    PC=0xbfc00008    2404754e addiu $4, $0, 30030
    PC=0xbfc0000c    14800002 bne $4, $0, 0xbfc00014
    PC=0xbfc00010    0064001a div $3, $4
    PC=0xbfc00018    2401ffff addiu $1, $0, -1
    PC=0xbfc0001c    14810004 bne $4, $1, 0xbfc0002c
    PC=0xbfc00020    3c018000 lui $1, -32768
    PC=0xbfc00030    00001010 mfhi $2
    PC=0xbfc00034    00801821 addu $3, $4, $0
    PC=0xbfc00038    00402021 addu $4, $2, $0
    PC=0xbfc0003c    1480fff3 bne $4, $0, 0xbfc00008
    PC=0xbfc00040    00000000 sll $0, $0, 0
    PC=0xbfc0000c    14800002 bne $4, $0, 0xbfc00014
    PC=0xbfc00010    0064001a div $3, $4
    PC=0xbfc00018    2401ffff addiu $1, $0, -1
    PC=0xbfc0001c    14810004 bne $4, $1, 0xbfc0002c
    PC=0xbfc00020    3c018000 lui $1, -32768
    PC=0xbfc00030    00001010 mfhi $2
    PC=0xbfc00034    00801821 addu $3, $4, $0
    PC=0xbfc00038    00402021 addu $4, $2, $0
    PC=0xbfc0003c    1480fff3 bne $4, $0, 0xbfc00008
    PC=0xbfc00040    00000000 sll $0, $0, 0
    PC=0xbfc0000c    14800002 bne $4, $0, 0xbfc00014
    PC=0xbfc00010    0064001a div $3, $4
    PC=0xbfc00018    2401ffff addiu $1, $0, -1
    PC=0xbfc0001c    14810004 bne $4, $1, 0xbfc0002c
    PC=0xbfc00020    3c018000 lui $1, -32768
    PC=0xbfc00030    00001010 mfhi $2
    PC=0xbfc00034    00801821 addu $3, $4, $0
    PC=0xbfc00038    00402021 addu $4, $2, $0
    PC=0xbfc0003c    1480fff3 bne $4, $0, 0xbfc00008
    PC=0xbfc00040    00000000 sll $0, $0, 0
    PC=0xbfc0000c    14800002 bne $4, $0, 0xbfc00014
    PC=0xbfc00010    0064001a div $3, $4
    PC=0xbfc00018    2401ffff addiu $1, $0, -1
    PC=0xbfc0001c    14810004 bne $4, $1, 0xbfc0002c
    PC=0xbfc00020    3c018000 lui $1, -32768
    PC=0xbfc00030    00001010 mfhi $2
    PC=0xbfc00034    00801821 addu $3, $4, $0
    PC=0xbfc00038    00402021 addu $4, $2, $0
    PC=0xbfc0003c    1480fff3 bne $4, $0, 0xbfc00008
    PC=0xbfc00040    00000000 sll $0, $0, 0
    PC=0xbfc0000c    14800002 bne $4, $0, 0xbfc00014
    PC=0xbfc00010    0064001a div $3, $4
    PC=0xbfc00018    2401ffff addiu $1, $0, -1
    PC=0xbfc0001c    14810004 bne $4, $1, 0xbfc0002c
    PC=0xbfc00020    3c018000 lui $1, -32768
    PC=0xbfc00030    00001010 mfhi $2
    PC=0xbfc00034    00801821 addu $3, $4, $0
    PC=0xbfc00038    00402021 addu $4, $2, $0
    PC=0xbfc0003c    1480fff3 bne $4, $0, 0xbfc00008
    PC=0xbfc00040    00000000 sll $0, $0, 0
    PC=0xbfc0000c    14800002 bne $4, $0, 0xbfc00014
    PC=0xbfc00010    0064001a div $3, $4
    PC=0xbfc00018    2401ffff addiu $1, $0, -1
    PC=0xbfc0001c    14810004 bne $4, $1, 0xbfc0002c
    PC=0xbfc00020    3c018000 lui $1, -32768
    PC=0xbfc00030    00001010 mfhi $2
    PC=0xbfc00034    00801821 addu $3, $4, $0
    PC=0xbfc00038    00402021 addu $4, $2, $0
    PC=0xbfc0003c    1480fff3 bne $4, $0, 0xbfc00008
    PC=0xbfc00040    00000000 sll $0, $0, 0
    PC=0xbfc0000c    14800002 bne $4, $0, 0xbfc00014
    PC=0xbfc00010    0064001a div $3, $4
    PC=0xbfc00018    2401ffff addiu $1, $0, -1
    PC=0xbfc0001c    14810004 bne $4, $1, 0xbfc0002c
    PC=0xbfc00020    3c018000 lui $1, -32768
    PC=0xbfc00030    00001010 mfhi $2
    PC=0xbfc00034    00801821 addu $3, $4, $0
    PC=0xbfc00038    00402021 addu $4, $2, $0
    PC=0xbfc0003c    1480fff3 bne $4, $0, 0xbfc00008
    PC=0xbfc00040    00000000 sll $0, $0, 0
    PC=0xbfc0000c    14800002 bne $4, $0, 0xbfc00014
    PC=0xbfc00010    0064001a div $3, $4
    PC=0xbfc00018    2401ffff addiu $1, $0, -1
    PC=0xbfc0001c    14810004 bne $4, $1, 0xbfc0002c
    PC=0xbfc00020    3c018000 lui $1, -32768
    PC=0xbfc00030    00001010 mfhi $2
    PC=0xbfc00034    00801821 addu $3, $4, $0
    PC=0xbfc00038    00402021 addu $4, $2, $0
    PC=0xbfc0003c    1480fff3 bne $4, $0, 0xbfc00008
    PC=0xbfc00040    00000000 sll $0, $0, 0
    PC=0xbfc0000c    14800002 bne $4, $0, 0xbfc00014
    PC=0xbfc00010    0064001a div $3, $4
    PC=0xbfc00018    2401ffff addiu $1, $0, -1
    PC=0xbfc0001c    14810004 bne $4, $1, 0xbfc0002c
    PC=0xbfc00020    3c018000 lui $1, -32768
    PC=0xbfc00030    00001010 mfhi $2
    PC=0xbfc00034    00801821 addu $3, $4, $0
    PC=0xbfc00038    00402021 addu $4, $2, $0
    PC=0xbfc0003c    1480fff3 bne $4, $0, 0xbfc00008
    PC=0xbfc00040    00000000 sll $0, $0, 0
    PC=0xbfc0000c    14800002 bne $4, $0, 0xbfc00014
    PC=0xbfc00010    0064001a div $3, $4
    PC=0xbfc00018    2401ffff addiu $1, $0, -1
    PC=0xbfc0001c    14810004 bne $4, $1, 0xbfc0002c
    PC=0xbfc00020    3c018000 lui $1, -32768
    PC=0xbfc00030    00001010 mfhi $2
    PC=0xbfc00034    00801821 addu $3, $4, $0
    PC=0xbfc00038    00402021 addu $4, $2, $0
    PC=0xbfc0003c    1480fff3 bne $4, $0, 0xbfc00008
    PC=0xbfc00040    00000000 sll $0, $0, 0
    PC=0xbfc00044    03e00008 jr $31

 Here's the final screen's-worth of output from VMIPS, in which the fact
 that the program terminated correctly can be seen:

    *************HALT*************

	Dumping:
	Reg Dump:  PC=bfc00054(ffffffff) HI=00000000 LO=00000002
	  DELAYING = FALSE (branch was NOT TAKEN) ; DELAY_PC=bfc00030
	 R00=00000000  R01=80000000  R02=00000000  R03=0000000b  R04=00000000 
	 R05=00000000  R06=00000000  R07=00000000  R08=00000000  R09=00000000 
	 R10=00000000  R11=00000448  R12=40107600  R13=40107600  R14=00000000 
	 R15=00000000  R16=00000000  R17=00000410  R18=401075f8  R19=401075f8 
	 R20=00000000  R21=080528c8  R22=00000018  R23=00000018  R24=00000000 
	 R25=00000000  R26=080524a8  R27=080524d8  R28=080524b8  R29=000003e0 
	 R30=401075f0  R31=401075f0 
	(stack dump not implemented)
	CP0 Dump Registers:
	 R00=00000000  R01=0000003f  R02=00000000  R03=00000018 
	 R04=401073d0  R05=401073d0  R06=00000000  R07=080528d8 
	 R08=00000030  R09=00000018  R10=00000000  R11=00000000 
	 R12=088523c8  R13=080523f8  R14=00000000  R15=00000528 
	Goodbye.

 The register with the answer is R03 (also known as $v1 to objdump, and
 also also known as $3). Note that this is the R03 which comes between
 "Reg Dump" and "(stack dump not implemented)" -- not the one which comes
 after "CP0 Dump Registers" and before "Goodbye"; that is Coprocessor
 Zero's register three, which is actually named EntryLo1. The DELAY_PC is
 used to implement the branch delay slot, as described in "doc/delay".

