.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH INVOKE 1 "vmips 1.0.3" "12/Jan/2002" "VMIPS Programmer's Manual"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
vmips \- VMIPS R3000-based MIPS simulator (running and customizing)
.SH "SYNOPSIS"
.PP
.Vb 1
\&  
.Ve
.Vb 4
\&  vmips [-D] [-o option_string] ... rom_file
\&  vmips --help
\&  vmips --version
\&  vmips --print-config
.Ve
.SH "DESCRIPTION"
When you invoke vmips, it loads a ROM file specified on the command line,
initializes and resets the MIPS processor, and begins execution at the first
address of the ROM file, which is normally loaded at address 0xbfc00000.
.SH "OPTIONS"
This is what the different command line options mean:
.Ip "\fB\-D\fR" 4
Turns on debugging of option parsing. This is not generally
useful to the end user unless you are confused about \s-1VMIPS\s0's
interpretation of your command line or startup \fIfile\fR\|(s).
\s-1VMIPS\s0 has to be compiled with \-\s-1DOPTIONS_DEBUG\s0 for this option
to be available.
.Ip "\fB--help\fR" 4
Prints a short summary of \s-1VMIPS\s0 command line options, and exits
successfully.
.Ip "\fB--version\fR" 4
Prints a short summary of \s-1VMIPS\s0 version and copyright information,
and exits successfully.
.Ip "\fB--print-config\fR" 4
Prints a short summary of \s-1VMIPS\s0 compile-time configuration information,
and exits successfully.
.Ip "\fB\-o something\fR" 4
Set the option \*(L"something\*(R" as if \*(L"something\*(R" were in your
\&.vmipsrc file.  See the \*(L"\s-1VMIPS\s0 options\*(R" section of the
\*(L"Customizing\*(R" chapter for more information on what kind
of things can go in your .vmipsrc file. You can use as many
\-o options on the command line as your shell will let you.
.Ip "\fBrom_file\fR" 4
Use the named file as the \s-1ROM\s0 file \s-1VMIPS\s0 should boot. This
option is mandatory.
.SH "FILES"
.Sh "\s-1VMIPS\s0 options"
The \s-1VMIPS\s0 simulator gets runtime options from four different sources,
in this order: first, it checks its compile-time defaults, which are
set by the site administrator in the source file \fIoptiontbl.h\fR. Then,
the system-wide configuration file is read; usually this is in
\fI/usr/local/share/vmipsrc\fR, but it may have been moved by the site
administrator. (This is configurable in the source file \fIoptions.h\fR, and
by specifying the --prefix and --sharedir options to the \s-1GNU\s0 \fBconfigure\fR
script when building \s-1VMIPS\s0.) Next, it checks the user's own configuration
file, usually the file \fI.vmipsrc\fR in your home directory. Last, it
reads the command line, and gets any options listed there.
.Sh "Format of the configuration file"
The configuration file may contain as many options per line as you want,
provided no line exceeds \s-1BUFSIZ\s0 (usually 1,024) characters.  Whitespace
separates options from one another. A string or number option named
\s-1NAME\s0 can appear as \s-1NAME\s0=\s-1VALUE\s0, where \s-1VALUE\s0 is the string or number
in question. If the number begins with 0x, it will be interpreted
as a 32-bit hexadecimal number, and if it begins with 0, it will be
interpreted as octal. Otherwise, it will be interpreted as a decimal
number. Numbers are always unsigned. A Boolean option named \s-1NAME\s0 can
appear as either \s-1NAME\s0 (to set it to \s-1TRUE\s0) or noNAME (to set it to \s-1FALSE\s0).
.Sh "Summary of configuration options"
The following is a list of the configuration options present in this
version of \s-1VMIPS\s0.
.PP
@include options.texi
\fBhaltdumpcpu\fR (type: Boolean)
.PP
Controls whether the \s-1CPU\s0 registers will be dumped on halt. The default value is \s-1FALSE\s0.
.PP
\fBhaltdumpcp0\fR (type: Boolean)
.PP
Controls whether the system control coprocessor (\s-1CP0\s0) registers
will be dumped on halt. The default value is \s-1FALSE\s0.
.PP
\fBexcpriomsg\fR (type: Boolean)
.PP
Controls whether exception prioritizing messages will
be printed. These messages attempt to explain which of
a number of exceptions caused by the same instruction
will be reported. The default value is \s-1FALSE\s0.
.PP
\fBexcmsg\fR (type: Boolean)
.PP
Controls whether every exception will cause a message
to be printed. The message gives the exception code, a
short explanation of the exception code, its priority,
the delay slot state of the virtual \s-1CPU\s0, and states
what type of memory access the exception was caused by,
if applicable. The default value is \s-1FALSE\s0.
.PP
\fBbootmsg\fR (type: Boolean)
.PP
Controls whether boot-time and halt-time messages will be printed.
These include \s-1ROM\s0 image size, self test messages, reset and halt
announcements, and possibly other messages. The default value is \s-1TRUE\s0.
.PP
\fBinstdump\fR (type: Boolean)
.PP
Controls whether every instruction executed will be disassembled
and printed.  The default value is \s-1TRUE\s0. The output is in the following format:
  
.PP
.Vb 1
\&  PC=0xbfc00000 [1fc00000] 24000000 li $zero,0
.Ve
The first column contains the \s-1PC\s0 (program counter), followed by
the physical translation of that address in brackets. The third
column contains the machine instruction word at that address,
followed by the assembly language corresponding to that word.
All of the constants except for the assembly language are in
hexadecimal.
.PP
\fBdumpcpu\fR (type: Boolean)
.PP
Controls whether the \s-1CPU\s0 registers will be dumped after every
instruction.  The default value is \s-1FALSE\s0. The output is in the following format:
  
.PP
.Vb 5
\&  Reg Dump: PC=bfc00080 Last Instr=241f001f HI=00000000 LO=00000000
\&  DELAY_STATE = NORMAL ; DELAY_PC=00000000 ; NEXT_EPC = bfc0007c
\&  R00=00000000 R01=00000001 R02=00000002 R03=00000003 R04=00000004 
\&  ...
\&  R30=0000001e R31=0000001f 
.Ve
(Some values have been omitted for brevity.)
Here, \s-1PC\s0 is the program counter, Last Instr is the last instruction
executed, \s-1HI\s0 and \s-1LO\s0 are the multiplication/division result registers,
\s-1DELAY_STATE\s0 and \s-1DELAY_PC\s0 are used in delay slot processing, \s-1NEXT_EPC\s0
is what the Exception \s-1PC\s0 would be if an exception were to occur, and
R00 ... R31 are the \s-1CPU\s0 general purpose registers. All values are in
hexadecimal.
.PP
\fBdumpcp0\fR (type: Boolean)
.PP
Controls whether the system control coprocessor (\s-1CP0\s0)
registers will be dumped after every instruction. 
 The default value is \s-1FALSE\s0. The output is in the following format:
  
.PP
.Vb 5
\&  CP0 Dump Registers:
\&  R00=00000100 R01=00001f00 R02=06a5ee00 R03=00000000 
\&  R04=7fffca10 R05=00000000 R06=00000000 R07=00000000 
\&  R08=7fb7e0aa R09=00000000 R10=6f6dd980 R11=00000000 
\&  R12=00485e18 R13=30002110 R14=4c04a8af R15=0000703b 
.Ve
Each of the R00 .. R15 are coprocessor zero registers.
Their values are displayed in hexadecimal.
.PP
\fBhaltibe\fR (type: Boolean)
.PP
If haltibe is set to \s-1TRUE\s0, the virtual machine will halt
when an instruction fetch causes a bus error (exception
code 6, Instruction bus error). This is useful if you
are expecting execution to jump into unmapped areas of
memory, and you want it to stop instead of calling the
exception handler. The default value is \s-1TRUE\s0.
.PP
\fBhaltjrra\fR (type: Boolean)
.PP
If haltjrra is set to \s-1TRUE\s0, the virtual machine will halt
when the instruction \*(L"jr \f(CW$31\fR\*(R" (also written \*(L"jr \f(CW$ra\fR")
is encountered. Since this is the instruction for a
procedure call to return, this is useful if you have
a simple procedure to run and you want execution to
terminate when it finishes. The default value is \s-1FALSE\s0.
.PP
\fBhaltbreak\fR (type: Boolean)
.PP
If haltbreak is set to \s-1TRUE\s0, the virtual machine will halt
when a breakpoint exception is encountered (exception
code 9). This is equivalent to halting when a \*(L"break\*(R"
instruction is encountered. The default value is \s-1TRUE\s0.
.PP
\fBinstcounts\fR (type: Boolean)
.PP
Set instcounts to \s-1TRUE\s0 if you want to see instruction
counts, a rough estimate of total runtime, and execution
speed in instructions per second when the virtual
machine halts.  The default value is \s-1FALSE\s0. The output is printed
at the end of the run, and is in the following format:
  
.PP
.Vb 2
\&  733737 instructions executed in 5.81484 seconds
\&  126183.545 instructions per second
.Ve
\fBromfile\fR (type: string)
.PP
This is the name of the file which will be initially
loaded into memory (at the address given in \*(L"loadaddr\*(R",
typically 0xbfc00000) and executed when the virtual
machine is reset. The default value is \*(L"romfile.rom\*(R".
.PP
\fBconfigfile\fR (type: string)
.PP
This is the name of the user configuration file. It
will be ~username-expanded and checked for configuration
options before the virtual machine boots. The default value is \*(L"~/.vmipsrc\*(R".
.PP
\fBloadaddr\fR (type: number)
.PP
This is the virtual address where the \s-1ROM\s0 will be loaded.
Note that the \s-1MIPS\s0 reset exception vector is always 0xbfc00000
so unless you're doing something incredibly clever you should
plan to have some executable code at that address. Since the
caches and \s-1TLB\s0 are in an indeterminate state at the time of
reset, the load address must be in uncacheable memory which
is not mapped through the \s-1TLB\s0 (kernel segment \*(L"kseg1"). This
effectively constrains the valid range of load addresses to
between 0xa0000000 and 0xc0000000. The default value is 0xbfc00000.
.PP
\fBmemsize\fR (type: number)
.PP
This variable controls the size of the virtual \s-1CPU\s0's \*(L"physical\*(R"
memory in bytes. You might want to round this off to the nearest
page; you can determine the pagesize using utils/getpagesize.cc. The default value is 0x100000.
.PP
\fBmemdump\fR (type: Boolean)
.PP
If memdump is set, then the virtual machine will dump its \s-1RAM\s0
into a file named \*(L"memdump.bin\*(R" at the end of processing. The default value is \s-1FALSE\s0.
.PP
\fBreportirq\fR (type: Boolean)
.PP
If reportirq is set, then any change in the interrupt inputs from
a device will be reported on stderr. The default value is \s-1FALSE\s0.
.PP
\fBusetty\fR (type: Boolean)
.PP
If usetty is set, then the \s-1SPIM\s0\-compatible console device will be
configured. If it is not set, then no console device will be
available to the virtual machine. The default value is \s-1TRUE\s0.
.PP
\fBttydev\fR (type: string)
.PP
This pathname will be used as the device from which reads
from the console device will take their data, and to which writes
to the console device will send their data. If the \s-1OS\s0 supports
\fIttyname\fR\|(3), that call will be used to guess the default pathname. The default value is \*(L"/dev/tty\*(R".
.PP
\fBdebug\fR (type: Boolean)
.PP
If debug is set, then the gdb remote serial protocol backend will
be enabled in the virtual machine. This will cause the machine to
wait for gdb to attach and \*(L"continue\*(R" before booting the \s-1ROM\s0 file.
If debug is not set, then the machine will boot the \s-1ROM\s0 file
without pausing. The default value is \s-1FALSE\s0.
.PP
\fBrealtime\fR (type: Boolean)
.PP
If realtime is set, then the clock device will cause simulated
time to run at some fraction of real time, determined by the
`timeratio\*(R' option. If realtime is not set, then simulated time
will run at the speed given by the `clockspeed\*(R' option. The default value is \s-1FALSE\s0.
.PP
\fBtimeratio\fR (type: number)
.PP
If the realtime option is set, this option gives the number of times
slower than real time at which simulated time will run. It has
no effect if realtime is not set. The default value is 200.
.PP
\fBclockspeed\fR (type: number)
.PP
If the realtime option is not set, this option gives the speed of
simulated time in Hz. It has no effect if realtime is set. The default value is 25000000.
.PP
\fBclockintr\fR (type: number)
.PP
This option gives the frequency of clock interrupts, in nanoseconds
of simulated time. The default value is 1000.
.SH "BUGS"
For instructions on reporting bugs, see
the \*(L"Reporting Bugs\*(R" appendix of the Info manual.
.SH "SEE ALSO"
\fIas\fR\|(1), \fIld\fR\|(1), \fIgdb\fR\|(1), 
and the Info entries for \fIvmips\fR, \fIgcc\fR, \fIas\fR,
\fIld\fR, \fIbinutils\fR and \fIgdb\fR.
.PP
Important: The information in this man page is an extract from the full
documentation of the VMIPS simulator, and is limited to the meaning of
the command-line options. If you didn't find what you were looking for here,
or you want more information, please refer to the Info file \fIvmips\fR
or the VMIPS Programmer's Manual.  Both are made from the Texinfo source
file vmips.texi.
.SH "AUTHOR"
VMIPS was written by Brian Gaeke.
.SH "COPYRIGHT"
Copyright (c) 2001 Brian R. Gaeke.
.PP
Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.
.PP
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

.rn }` ''
.IX Title "INVOKE 1"
.IX Name "vmips - VMIPS R3000-based MIPS simulator (running and customizing)"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "OPTIONS"

.IX Item "\fB\-D\fR"

.IX Item "\fB--help\fR"

.IX Item "\fB--version\fR"

.IX Item "\fB--print-config\fR"

.IX Item "\fB\-o something\fR"

.IX Item "\fBrom_file\fR"

.IX Header "FILES"

.IX Subsection "\s-1VMIPS\s0 options"

.IX Subsection "Format of the configuration file"

.IX Subsection "Summary of configuration options"

.IX Header "BUGS"

.IX Header "SEE ALSO"

.IX Header "AUTHOR"

.IX Header "COPYRIGHT"

