
The current (re-)implementation of memory-mapped devices
--------------------------------------------------------
 
 The central problem with the current half-implementation of memory
 mapped devices is that you can't map them at multiple locations, which
 makes their design completely different from all the other kinds of
 mappable entities. The assumption was that you wouldn't ever really
 want to map a device at more than one separate location, so it was
 okay to hardwire one physical base address (Range::base field) in each
 mappable device. But this also would necessitate a series of calls for
 instantiation as follows:
 
 	/* Test device at base phys addr 0x01000000 */
 	testdev = new TestDev(0x01000000);
 	physmem->add_device_mapping(testdev);
 
 whereas you'd really want it to be like
 
 	/* Test device at base phys addr 0x01000000 */
 	testdev = new TestDev();
 	physmem->add_device_mapping(testdev, 0x01000000);
 
 so that it looked vaguely like add_core_mapping and add_file_mapping,
 which both take a mapping-source (host machine memory address and
 filehandle, respectively) as well as a destination address. Also, this
 would allow for multiple base-addresses for a device.
 
 The solution as I envision it is to remove the base address from
 consideration when actually doing stuff to any mappable entity; that is,
 instead of having everything know its base address and having to subtract
 it from any physical address accessed, just subtract the base address
 of the Range object before the mappable entity ever sees it.
 
 The other part of this is that there is no entity which corresponds
 even roughly to a DeviceMap object which means "thing taken care of
 by the OS's virtual memory architecture." The performance differential
 incurred if a separate object were created for this should be investigated.
